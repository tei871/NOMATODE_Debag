<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEMATODE: Triple Crisis</title>
    <style>
        body { background: #050505; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: 'MS Gothic', 'Courier New', monospace; overflow: hidden; color: #00ff00; touch-action: none; }
        
        #container { 
            position: relative; 
            width: 400px; 
            height: 440px; 
            max-width: 95vw;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }
        
        canvas { border: 4px solid #111; image-rendering: pixelated; width: 400px; height: 400px; background: #000; display: block; box-sizing: border-box; }
        
        #ui { 
            height: 40px;
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 14px; 
            text-shadow: 2px 2px #000; 
            pointer-events: none; 
            z-index: 150; 
            box-sizing: border-box;
            padding: 0 5px;
        }
        
        .vignette { 
            position: absolute; bottom: 0; left: 0; width: 400px; height: 400px; 
            pointer-events: none; 
            box-shadow: inset 0 0 120px rgba(0,0,0,0.95); 
            outline: 10px solid black;
            z-index: 10;
        }
        
        /* レバーのデザインを初期の●スタイルに変更 */
        #stick-base { position: fixed; bottom: 50px; left: 50px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border-radius: 50%; display: none; border: 2px solid rgba(0,255,0,0.2); z-index: 1000; touch-action: none; }
        #stick-knob { position: absolute; top: 30px; left: 30px; width: 60px; height: 60px; background: rgba(0, 255, 0, 0.3); border-radius: 50%; pointer-events: none; transition: transform 0.05s linear; display: flex; justify-content: center; align-items: center; border: 1px solid rgba(0, 255, 0, 0.5); }

        #intro-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 30px; box-sizing: border-box; cursor: pointer; }
        #intro-text { color: #ccc; font-size: 14px; line-height: 2.2; letter-spacing: 1px; max-width: 320px; text-align: left; z-index: 202; pointer-events: none; text-shadow: 0 0 10px #000; display: none; }
        #click-to-start { color: #00ff00; font-size: 12px; z-index: 203; border: 1px solid #00ff00; padding: 10px 20px; background: rgba(0,255,0,0.1); }
        #logo { font-family: 'MS Gothic', 'Courier New', monospace; letter-spacing: 5px; border-bottom: 1px solid #ff0000; padding-bottom: 10px; }
        .logo-char { display: inline-block; transition: opacity 0.05s; }
        .blink-off { opacity: 0.1; }
    </style>
</head>
<body>

<div id="intro-screen" onmousedown="handleIntroClick()" ontouchstart="handleIntroClick(event)">
    <canvas id="introCanvas" style="position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.15; z-index:201;"></canvas>
    <div id="click-to-start">[ TAP TO INITIALIZE SYSTEM ]</div>
    <div id="intro-text">
        あるとき、月から得体のしれぬものが居住区に落ち、なかから蠢く線虫が現れ、人々の姿が消えた。古書によれば、残された「緑の祭壇」に遺物を集めることで線虫らを浄化できると記述がある。記録をもとに調査員は向かった。<br><br>
        <span style="color:#666; font-size:10px;">[ TAP / ENTER / SPACE TO SKIP ]</span>
    </div>
</div>

<div id="start-screen" style="position:absolute; background:rgba(0,0,0,0.98); padding:40px; text-align:center; z-index:100; border:1px solid #ff0000; width:280px; color:#ff0000; display:none;">
    <h1 id="logo"><span class="logo-char">N</span><span class="logo-char">E</span><span class="logo-char">M</span><span class="logo-char">A</span><span class="logo-char">T</span><span class="logo-char">O</span><span class="logo-char">D</span><span class="logo-char">E</span></h1>
    <p style="font-size:11px; line-height:1.8; color:#aaa; text-align: left;">
        - Explore the depths and collect artifacts.<br>
        - Enter the shrine to restore your HP.<br>
        <span style="color:#ff0000;">- Complete 3 levels to purify.</span>
    </p>
    <button onmousedown="startGame()" ontouchstart="startGame()" style="padding:12px 40px; cursor:pointer; background:#111; color:#ff0000; border:1px solid #ff0000; font-weight: bold;">[ START INVESTIGATION ]</button>
</div>

<div id="container">
    <div id="ui">
        <div id="hearts" style="color:#ff0044;"></div>
        <div id="status-text">LEVEL 1</div>
        <div>ARTIFACT: <span id="t-count">0</span>/3</div>
    </div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div class="vignette"></div>
</div>

<div id="stick-base">
    <div id="stick-knob"></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const introCanvas = document.getElementById('introCanvas'), ictx = introCanvas.getContext('2d'), knob = document.getElementById('stick-knob');
    let audioCtx = null, bgmNode = null, bgmGain = null, introBGM = null, p, currentMap, state = "intro", frame = 0, enemies = [], rollY = 420, resetTimer = 0, currentLevel = 1, treasures = [], noiseTimer = 0, animationId = null, audioStarted = false, whiteOutRadius = 0, lastIntroActionTime = 0;
    let isEndingTriggered = false, footprints = []; 
    const keys = {}; let stick = { active: false, x: 0, y: 0, startX: 0, startY: 0, tapped: false };
    const levels = [{ name: "LEVEL 1: GREEN DEPTHS", color: "#080808", mapColor: "#050a05", enemyCount: 2, enemyTypes: [0] }, { name: "LEVEL 2: BLOOD LAB", color: "#1a0505", mapColor: "#220808", enemyCount: 3, enemyTypes: [0, 1] }, { name: "LEVEL 3: CYAN ABYSS", color: "#050a1a", mapColor: "#081a22", enemyCount: 4, enemyTypes: [0, 1, 2] }];
    let introNematodes = Array.from({length: 8}, () => ({ x: Math.random() * 400, y: Math.random() * 400, segs: Array.from({length: 20}, () => ({x:0, y:0})), angle: Math.random() * Math.PI * 2 }));

    const charSprite = [[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,1,1,1,0,0],[1,1,1,1,1,1,0,0],[0,0,1,1,1,1,0,0],[0,0,1,1,1,1,0,0],[0,0,1,1,1,1,0,0],[0,0,1,0,0,1,0,0]];

    function drawPlayer(x, y, color, direction, isMoving) {
        ctx.save(); ctx.translate(x - 12, y - 12); const px = 3; const animFrame = isMoving ? (Math.floor(frame / 10) % 2) : -1;
        charSprite.forEach((row, rowIdx) => { row.forEach((pixel, colIdx) => { if (pixel) { if (rowIdx >= 6) { if (animFrame === 0 && colIdx === 2) return; if (animFrame === 1 && colIdx === 5) return; } ctx.fillStyle = color; let drawX = direction === 'right' ? (7 - colIdx) * px : colIdx * px; ctx.fillRect(drawX, rowIdx * px, px, px); } }); }); ctx.restore();
    }
    
    // オーディオ・エフェクト関連
    function playStepSound() { if (!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.frequency.setValueAtTime(80, now); o.frequency.exponentialRampToValueAtTime(40, now + 0.1); g.gain.setValueAtTime(0.04, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.1); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(now + 0.1); }
    function handleIntroClick(e) { if (e) { e.preventDefault(); e.stopPropagation(); } const now = Date.now(); if (!audioStarted) { audioStarted = true; lastIntroActionTime = now; document.getElementById('click-to-start').style.display = 'none'; document.getElementById('intro-text').style.display = 'block'; startIntroAudio(); } else { if (now - lastIntroActionTime > 500) skipIntro(); } }
    function startIntroAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); if(introBGM) return; const mainG = audioCtx.createGain(); mainG.gain.setValueAtTime(0, audioCtx.currentTime); mainG.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime + 3); mainG.connect(audioCtx.destination); const o = audioCtx.createOscillator(); const lfo = audioCtx.createOscillator(), lfoG = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = 55; lfo.frequency.value = 0.15; lfoG.gain.value = 2; lfo.connect(lfoG); lfoG.connect(o.frequency); o.connect(mainG); o.start(); lfo.start(); const pianoInterval = setInterval(() => { if (state !== "intro") { clearInterval(pianoInterval); return; } playPianoNote(mainG); }, 2500); playPianoNote(mainG); introBGM = {o, mainG, lfo, interval: pianoInterval}; }
    function playPianoNote(targetGain) { const notes = [220, 261.63, 329.63, 392.00, 493.88, 523.25]; const freq = notes[Math.floor(Math.random() * notes.length)]; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = 'sine'; o.frequency.setValueAtTime(freq, audioCtx.currentTime); g.gain.setValueAtTime(0, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.1); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 5); o.connect(g); g.connect(targetGain); o.start(); o.stop(audioCtx.currentTime + 5); }
    function stopIntroAudio() { if (introBGM) { introBGM.mainG.gain.setTargetAtTime(0, audioCtx.currentTime, 0.8); setTimeout(() => { if(introBGM) {introBGM.o.stop(); introBGM.lfo.stop(); introBGM = null;} }, 1200); } }
    function skipIntro() { if (state !== "intro" || !audioStarted) return; state = "title"; stopIntroAudio(); document.getElementById('intro-screen').style.display = 'none'; document.getElementById('start-screen').style.display = 'block'; }
    function updateLogoBlink() { if (state !== "title") return; if (Math.random() < 0.02) { const chars = document.querySelectorAll('.logo-char'), target = chars[Math.floor(Math.random() * chars.length)]; target.classList.add('blink-off'); setTimeout(() => target.classList.remove('blink-off'), 50 + Math.random() * 100); } }
    function safeStopBGM() { if (bgmGain) { try { bgmGain.gain.cancelScheduledValues(0); bgmGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.03); } catch(e) {} } }
    
    function initGameVars() { p = { x: 200, y: 250, speed: 4, hp: 2, maxHp: 2, hasT: false, saved: 0, invul: 0, dir: 'left', moving: false }; currentMap = 0; currentLevel = 1; frame = 0; enemies = []; rollY = 420; resetTimer = 0; noiseTimer = 0; whiteOutRadius = 0; isEndingTriggered = false; footprints = []; spawnTreasures(); updateUI(); if ('ontouchstart' in window) document.getElementById('stick-base').style.display = 'block'; state = "play"; }
    function spawnTreasures() { treasures = [null, null]; for (let i = 2; i <= 4; i++) treasures.push({ x: 50 + Math.random() * 300, y: 50 + Math.random() * 300, active: true }); }
    function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
    
    // SE/BGMロジック
    function playDepositSound() { if (!audioCtx) return; const now = audioCtx.currentTime, o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = 'sine'; o.frequency.setValueAtTime(60, now); o.frequency.exponentialRampToValueAtTime(40, now + 0.8); g.gain.setValueAtTime(0.2, now); g.gain.linearRampToValueAtTime(0, now + 0.8); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(now + 0.8); }
    function playLevelUpSound() { if (!audioCtx) return; const now = audioCtx.currentTime, duration = 1.5; [40, 42, 55].forEach((freq, i) => { const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = i === 2 ? 'sawtooth' : 'sine'; o.frequency.setValueAtTime(freq, now); const lfo = audioCtx.createOscillator(), lfoGain = audioCtx.createGain(); lfo.frequency.value = 15; lfoGain.gain.value = 5; lfo.connect(lfoGain); lfoGain.connect(o.frequency); lfo.start(now); g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.15, now + 0.2); g.gain.linearRampToValueAtTime(0, now + duration); o.connect(g); g.connect(audioCtx.destination); o.start(now); o.stop(now + duration); lfo.stop(now + duration); }); }
    function playDamageNoise() { if (!audioCtx) return; const bufferSize = audioCtx.sampleRate * 0.15, buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate), data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1; const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.1, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15); noise.connect(g); g.connect(audioCtx.destination); noise.start(); }
    function playFomilyBell(isVictory = false) { if (!audioCtx) return; const now = audioCtx.currentTime; const melody = [659.25, 523.25, 349.23, 523.25, 587.33, 880.00, 0, 587.33, 659.25, 493.88, 329.63, 523.25]; const times = [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1.05, 1.2, 1.35, 1.5, 1.65], gainVal = isVictory ? 0.08 : 0.03; melody.forEach((f, i) => { if (f === 0) return; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = isVictory ? 'square' : 'triangle'; o.frequency.setValueAtTime(f, now + times[i]); g.gain.setValueAtTime(0, now + times[i]); g.gain.linearRampToValueAtTime(gainVal, now + times[i] + 0.02); g.gain.exponentialRampToValueAtTime(0.001, now + times[i] + (isVictory ? 0.8 : 0.4)); o.connect(g); g.connect(audioCtx.destination); o.start(now + times[i]); o.stop(now + times[i] + 1.0); }); }
    function playGetSound() { if (!audioCtx) return; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = 'square'; o.frequency.setValueAtTime(1200, audioCtx.currentTime); g.gain.setValueAtTime(0.03, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.1); }
    
    class Nematode { 
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.color = ["#00ff66", "#ff3333", "#00ccff"][type]; this.segs = Array.from({length: 10}, () => ({x, y})); this.phase = Math.random() * 10; } 
        update(tx, ty) { 
            let speed = 0.02 + (currentLevel * 0.012); 
            if (this.type === 1) speed *= (Math.sin(frame * 0.05) > 0.5) ? 3 : 0.5; 
            if (this.type === 2) { speed *= 1.5; tx += Math.sin(frame * 0.1) * 30; } 
            this.x += (tx - this.x) * speed; this.y += (ty - this.y) * speed; this.phase += 0.2; 
            let head = { x: this.x + Math.sin(this.phase)*6, y: this.y + Math.cos(this.phase)*6 }; 
            for(let i=0; i<this.segs.length; i++) { let target = i === 0 ? head : this.segs[i-1]; this.segs[i].x += (target.x - this.segs[i].x) * 0.35; this.segs[i].y += (target.y - this.segs[i].y) * 0.35; } 
        } 
        draw() { 
            this.segs.forEach((s, i) => { ctx.fillStyle = i === 0 ? "#fff" : this.color; ctx.beginPath(); ctx.arc(s.x, s.y, 5 - i*0.4, 0, Math.PI*2); ctx.fill(); }); 
        } 
    }
    
    function handleGlobalInput(e) { 
        if (state === "intro") return; 
        if (e.type === 'touchstart' || e.type === 'mousedown') { 
            const rect = canvas.getBoundingClientRect(); 
            const touchX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX; 
            const touchY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY; 
            const tx = touchX - rect.left; const ty = touchY - rect.top; 
            if (state !== "play") { stick.tapped = true; } 
            else if (tx < 200 && ty > 200) { stick.active = true; stick.startX = touchX; stick.startY = touchY; } 
            else { stick.tapped = true; } 
        } else if (e.type === 'touchmove' && stick.active) { 
            const touch = e.touches[0], dx = touch.clientX - stick.startX, dy = touch.clientY - stick.startY, dist = Math.min(40, Math.hypot(dx, dy)), angle = Math.atan2(dy, dx); 
            stick.x = (Math.cos(angle) * dist) / 40; stick.y = (Math.sin(angle) * dist) / 40; 
            knob.style.transform = `translate(${stick.x * 40}px, ${stick.y * 40}px)`; e.preventDefault(); 
        } else if (e.type === 'touchend' || e.type === 'mouseup') { 
            stick.active = false; stick.x = 0; stick.y = 0; knob.style.transform = `translate(0, 0)`; 
        } 
    }

    window.addEventListener('touchstart', handleGlobalInput, {passive: false}); window.addEventListener('touchmove', handleGlobalInput, {passive: false}); window.addEventListener('touchend', handleGlobalInput); window.addEventListener('mousedown', handleGlobalInput); window.addEventListener('mouseup', handleGlobalInput);
    window.onkeydown = e => { keys[e.code] = true; if (state === "intro") { handleIntroClick(); } else if (state === "title" && (e.code === "Enter" || e.code === "Space")) { startGame(); } }; window.onkeyup = e => keys[e.code] = false;
    
    function startGame() { initAudio(); document.getElementById('start-screen').style.display = 'none'; initGameVars(); updateBGM(); if(!animationId) gameLoop(); }
    function updateUI() { document.getElementById('status-text').innerText = levels[currentLevel-1].name; document.getElementById('t-count').innerText = p.saved; document.getElementById('hearts').innerHTML = "■".repeat(Math.max(0, p.hp)); }
    
    function update() { 
        if (state === "intro") { introNematodes.forEach(n => { n.angle += 0.02; n.x += Math.cos(n.angle); n.y += Math.sin(n.angle); if(n.x < 0) n.x = 400; if(n.x > 400) n.x = 0; if(n.y < 0) n.y = 400; if(n.y > 400) n.y = 0; let head = {x: n.x, y: n.y}; for(let i=0; i<n.segs.length; i++) { let target = i===0 ? head : n.segs[i-1]; n.segs[i].x += (target.x - n.segs[i].x) * 0.2; n.segs[i].y += (target.y - n.segs[i].y) * 0.2; } }); return; } 
        if (state !== "play") { if (state === "title") updateLogoBlink(); resetTimer++; if (state === "ending") { if (resetTimer > 60 && (keys['Space'] || keys['Enter'] || stick.tapped)) { isEndingTriggered = true; stick.tapped = false; } if (isEndingTriggered) { whiteOutRadius += 8; if (whiteOutRadius > 500) { state = "title"; document.getElementById('start-screen').style.display = 'block'; } } } else if (resetTimer > 60 && (keys['Space'] || keys['Enter'] || stick.tapped)) { stick.tapped = false; state = "title"; document.getElementById('start-screen').style.display = 'block'; } return; } 
        if (noiseTimer > 0) { noiseTimer--; return; }
        
        let mvX = 0, mvY = 0; if (keys['ArrowUp'] || keys['KeyW']) mvY -= 1; if (keys['ArrowDown'] || keys['KeyS']) mvY += 1; if (keys['ArrowLeft'] || keys['KeyA']) mvX -= 1; if (keys['ArrowRight'] || keys['KeyD']) mvX += 1; 
        let moveX = mvX + stick.x; let moveY = mvY + stick.y; p.x += moveX * p.speed; p.y += moveY * p.speed; if (moveX < -0.1) p.dir = 'left'; else if (moveX > 0.1) p.dir = 'right'; p.moving = Math.hypot(moveX, moveY) > 0.1;
        
        if (p.moving) { if (frame % 12 === 0) { playStepSound(); const side = (frame / 12) % 2 === 0 ? -6 : 6; footprints.push({ x: p.x + side, y: p.y + 6, life: 60 }); } }
        footprints.forEach((f, i) => { f.life--; if(f.life <= 0) footprints.splice(i, 1); });
        
        let oldMap = currentMap;
        if (currentMap === 0) { if (p.y < 0) { currentMap = 1; p.y = 380; } else if (p.y > 400) { currentMap = 4; p.y = 20; } else if (p.x < 0) { currentMap = 3; p.x = 380; } else if (p.x > 400) { currentMap = 2; p.x = 20; } }
        else if (currentMap === 1) { if (p.y > 400) { currentMap = 0; p.y = 20; } else { p.x = Math.max(10, Math.min(390, p.x)); p.y = Math.max(10, p.y); } }
        else if (currentMap === 2) { if (p.x < 0) { currentMap = 0; p.x = 380; } else { p.x = Math.min(390, p.x); p.y = Math.max(10, Math.min(390, p.y)); } }
        else if (currentMap === 3) { if (p.x > 400) { currentMap = 0; p.x = 20; } else { p.x = Math.max(10, p.x); p.y = Math.max(10, Math.min(390, p.y)); } }
        else if (currentMap === 4) { if (p.y < 0) { currentMap = 0; p.y = 380; } else { p.y = Math.min(390, p.y); p.x = Math.max(10, Math.min(390, p.x)); } }
        
        if (oldMap !== currentMap) { if (currentMap === 1) { p.hp = p.maxHp; playFomilyBell(false); } enemies = []; footprints = []; updateBGM(); updateUI(); }
        
        if (currentMap !== 1) { 
            const config = levels[currentLevel-1]; 
            if (Math.random() < 0.03 && enemies.length < config.enemyCount) { const type = config.enemyTypes[Math.floor(Math.random() * config.enemyTypes.length)]; enemies.push(new Nematode(Math.random()*400, -20, type)); } 
            for(let i = enemies.length - 1; i >= 0; i--) { 
                enemies[i].update(p.x, p.y); 
                if (p.invul === 0 && Math.hypot(p.x - enemies[i].x, p.y - enemies[i].y) < 15) { p.hp--; p.invul = 60; playDamageNoise(); updateUI(); if (p.hp <= 0) { state = "dead"; resetTimer = 0; safeStopBGM(); return; } } 
            } 
        } else if (p.hasT && Math.hypot(p.x - 200, p.y - 60) < 40) { 
            p.saved++; p.hasT = false; playDepositSound(); updateUI(); 
            if (p.saved >= 3) { 
                if (currentLevel < 3) { currentLevel++; p.saved = 0; spawnTreasures(); noiseTimer = 40; playLevelUpSound(); updateUI(); updateBGM(); } 
                else { state = "ending"; resetTimer = 0; rollY = 400; safeStopBGM(); playFomilyBell(true); isEndingTriggered = false; } 
            } 
        }
        
        let t = treasures[currentMap]; if (t && t.active && !p.hasT && Math.hypot(p.x - t.x, p.y - t.y) < 25) { t.active = false; p.hasT = true; playGetSound(); }
        if (p.invul > 0) p.invul--; frame++;
    }
    
    function draw() { 
        if (state === "intro") { ictx.clearRect(0,0,400,400); introNematodes.forEach(n => { n.segs.forEach((s, i) => { ictx.fillStyle = `rgba(100, 255, 100, ${0.5 - i*0.02})`; ictx.beginPath(); ictx.arc(s.x, s.y, 4 - i*0.2, 0, Math.PI*2); ictx.fill(); }); }); return; }
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,400,400); if (state === "title") return; ctx.fillStyle = levels[currentLevel-1].mapColor; ctx.fillRect(0,0,400,400);
        
        // コンビニ看板
        if (currentMap === 0) { ctx.fillStyle = "#0070c0"; ctx.fillRect(120, 0, 160, 15); ctx.fillStyle = "#fff"; ctx.fillRect(120, 15, 160, 5); ctx.fillStyle = "#00a040"; ctx.fillRect(120, 20, 160, 5); }
        // 祭壇エリア
        if (currentMap === 1) { ctx.fillStyle = "#eee"; ctx.fillRect(50, 50, 300, 300); ctx.fillStyle = "#00a040"; ctx.fillRect(170, 40, 60, 40); }
        
        // 秘宝の描画（光彩付き）
        let t = treasures[currentMap]; 
        if (t && t.active) { 
            ctx.save();
            ctx.fillStyle = "#0ff";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#0ff";
            ctx.beginPath(); 
            ctx.arc(t.x, t.y, 8, 0, Math.PI*2); 
            ctx.fill(); 
            ctx.restore();
        }

        if (state === "play") { 
            footprints.forEach(f => { ctx.fillStyle = `rgba(80, 150, 80, ${f.life / 200})`; ctx.fillRect(f.x - 2, f.y - 1, 4, 3); }); 
            enemies.forEach(en => en.draw()); 
            if (p.invul % 10 < 5) drawPlayer(p.x, p.y, p.hasT ? "#0ff" : "#0f0", p.dir, p.moving); 
            if (p.hasT) { ctx.strokeStyle = "#0ff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, 15 + Math.sin(frame/5)*3, 0, Math.PI*2); ctx.stroke(); } 
        }

        if (state === "dead") { ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,400,400); ctx.fillStyle = "#f00"; ctx.textAlign = "center"; ctx.font = "18px monospace"; ctx.fillText("ERROR: SUBJECT DECEASED", 200, 180); if(resetTimer > 60) { ctx.font = "12px monospace"; ctx.fillText("TAP TO RETURN TO TITLE", 200, 230); } }
        else if (state === "ending") { ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0,0,400,400); ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.font = "20px serif"; ctx.fillText("PURIFICATION COMPLETE", 200, rollY); ctx.font = "14px serif"; ctx.fillText("THE WORLD IS RESTORED", 200, rollY + 60); if (rollY > 150) rollY -= 0.7; if (resetTimer > 60 && !isEndingTriggered) { ctx.font = "10px monospace"; ctx.fillStyle = "#888"; ctx.fillText("TAP TO FINALIZE PURIFICATION", 200, 350); } if (whiteOutRadius > 0) { ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(200, 200, whiteOutRadius, 0, Math.PI*2); ctx.fill(); } }
        if (noiseTimer > 0) { ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.2})`; ctx.fillRect(0, Math.random()*400, 400, 15); }
    }
    
    function updateBGM() { if (!audioCtx || state !== "play") return; safeStopBGM(); const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = 70 + (currentLevel * 12) + (currentMap * 5); g.gain.setValueAtTime(0, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 0.1); o.connect(g); g.connect(audioCtx.destination); o.start(); bgmNode = o; bgmGain = g; }
    function gameLoop() { update(); draw(); animationId = requestAnimationFrame(gameLoop); } 
    gameLoop();
</script>
</body>
</html>
